-- NexaVault Collections
-- Run in Supabase SQL editor

create extension if not exists pgcrypto;

create table if not exists public.collections (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users (id) on delete cascade,
  name text not null,
  description text,
  created_at timestamptz not null default now()
);

create table if not exists public.collection_items (
  id bigint generated by default as identity primary key,
  collection_id uuid not null references public.collections (id) on delete cascade,
  item_id bigint not null references public.media_items (id) on delete cascade,
  created_at timestamptz not null default now(),
  unique(collection_id, item_id)
);

alter table public.collections enable row level security;
alter table public.collection_items enable row level security;

-- Collections: per-user
drop policy if exists "collections_select_own" on public.collections;
create policy "collections_select_own"
on public.collections for select
using (auth.uid() = user_id);

drop policy if exists "collections_insert_own" on public.collections;
create policy "collections_insert_own"
on public.collections for insert
with check (auth.uid() = user_id);

drop policy if exists "collections_update_own" on public.collections;
create policy "collections_update_own"
on public.collections for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "collections_delete_own" on public.collections;
create policy "collections_delete_own"
on public.collections for delete
using (auth.uid() = user_id);

-- Collection items: allow operations only if the collection belongs to the user
drop policy if exists "collection_items_select_own" on public.collection_items;
create policy "collection_items_select_own"
on public.collection_items for select
using (
  exists (
    select 1 from public.collections c
    where c.id = collection_items.collection_id
      and c.user_id = auth.uid()
  )
);

drop policy if exists "collection_items_insert_own" on public.collection_items;
create policy "collection_items_insert_own"
on public.collection_items for insert
with check (
  exists (
    select 1 from public.collections c
    where c.id = collection_items.collection_id
      and c.user_id = auth.uid()
  )
);

drop policy if exists "collection_items_delete_own" on public.collection_items;
create policy "collection_items_delete_own"
on public.collection_items for delete
using (
  exists (
    select 1 from public.collections c
    where c.id = collection_items.collection_id
      and c.user_id = auth.uid()
  )
);

-- grants
grant usage on schema public to anon, authenticated;
grant select, insert, update, delete on table public.collections to anon, authenticated;
grant select, insert, update, delete on table public.collection_items to anon, authenticated;
grant usage, select on all sequences in schema public to anon, authenticated;
